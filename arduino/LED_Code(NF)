   // This code is meant to take at most 10 inputs and display them in WS2812B individually addressed LEDs
   // 9/3/2018 : Now keeps track of what LEDs are on and how long each have been on (almost)
   // Changes needed: Find why the leds never turn off. currently the time on is not changing past 30miliseconds.
   // 
   
   
   
   
   
    #include <FastLED.h>
    #define LED_PIN     7
    #define NUM_LEDS    11
    #define BRIGHTNESS 30       // 0-64






    long previousMillis_1 = 0;
    long previousMillis_2 = 0;
    long onTime_1 = 10000; // 10 seconds
    long onTime_2 = 1000;   // 1 seconds   
    int ledStatus[] = {0,0,0,0,0,0,0,0,0,0,0};      // Each LED is assigned to the their according element. {LED1,LED2,LED3,...}
                                                    // 0 will indicate that the LED is off. 1 will indicate that the LED is on
                                                    // the intention for this is to let each LED have their own timing.
    
    CRGB leds[NUM_LEDS];
    
  /////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////////////////
  
    void setup() {
      Serial.begin(9600);                                     // Serial communication at 9600buad. 
      Serial.flush();                                         // cleaning serial port and setting up LED settings
      FastLED.addLeds<WS2812, LED_PIN, GRB>(leds, NUM_LEDS);  
      FastLED.setBrightness(BRIGHTNESS);
      FastLED.show();                                         //Initializing all LEDs to off
      }      
     
    
    void loop() {
    while (Serial.available() == 0);                                // Taking serial input and converting it to "input' integer
                   


      int input = Serial.read()-48;
                                                                //parseInt will always return a 0. this is why 0 will not be used in led strip
      Serial.println(input);
      
                                           //this is so far the easiest method in recieving integers from serial
                                                // rather than spliting input into bytes or translating from ascii
      ledStatus[input] = 1;
      leds[input] = CRGB(255,0,0);
      Serial.print(" This is the led that is now set to 1: ");
      Serial.print(ledStatus[1]);
      Serial.print("...This is the led that is now set to 1: ");
      Serial.print(ledStatus[2]);


      for(int ii = 1; ii<=1; ii++)
      {
      previousMillis_1 = millis();
      previousMillis_2 = millis();
      Serial.print("   setting times ran once    ");
      }                                  
        
      FastLED.show();
      
      
  
      
    
                                                   
  
                                                   // *** Depending if delay is caused by this, an array will be responsible for holding all the times
                                                   // that way we can use the array to set each led since later we will need ~70 which will most likely cause a delay setting 70 variables.
                                  // Will not execute untill input is set to -1.
    
    
    unsigned long currentMillis_1 = millis();
    unsigned long currentMillis_2 = millis();
    Serial.print("   currentMillis_1 - previousMillis_1 = ");
    if ((ledStatus[1] == 1)  && (currentMillis_1 - previousMillis_1 >= 1000))
    {
      
      leds[1] = CRGB::Black;
      FastLED.show();
      ledStatus[1] = 0;
       Serial.print("stuck in 1");
     }

  //   unsigned long currentMillis_2 = millis();
     //Serial.println(millis());
    if ((ledStatus[2] == 1) && (currentMillis_2 - previousMillis_2 >= 2000))
    {
      delay(1000);
      leds[2] = CRGB::Black;
      FastLED.show();
      ledStatus[2] = 0;
      Serial.print("stuck in 2");
    }



                                      
    }






    


    

    

