// Input in previous verisons were crashing if input was to fast occasionaly.
// Likely reason is that once the input was recieved , checking if the note was sharp or flat was taking too long.
// This version fixes that by using a boolean flag named note_check. Results are much better.
// However it is still flawed since we are using a slow 'for' loop to check the list.
// a better result will be to use binary searching. since the arrays we are searching are relatively small (88max)
//input_testing_2 will be using binary search. 

      #include <FastLED.h>
      #define LED_PIN     7
      #define NUM_LEDS    88
      #define BRIGHTNESS 15       // 0-64
      int ledNumber = 0;
      const byte numChars = 4;
      char endMarker = '\n';
      char comma = ',';
      char rc;
      int i = 0;      // used for indexing
      int j = 0;
      int LED = 0;    // Stores what LED is to be on
      byte keyboardSize[] = {2,4,7,9,11,14,16,19,21,23,26,28,31,33,35,38,40,43,45,47,50,52,55,57,59};
      long ledarray_beg[] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                                              0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
      char receivedChars[numChars]; 
      CRGB leds[NUM_LEDS];

void setup(){
        Serial.begin(9600);                         // Serial communication at 9600buad.
        FastLED.addLeds<WS2812, LED_PIN, GRB>(leds, NUM_LEDS); 
        FastLED.setBrightness(BRIGHTNESS);
        FastLED.show();                              //Initializing all LEDs to off
        Serial.println("Arduino Setup");
}

void receiveValue() {
      static byte ndx = 0;
     
      if (Serial.available() > 0) {
          rc = Serial.read();
          delay(10);
        
          if (rc != endMarker && rc != ',') {
              receivedChars[ndx] = rc;
              ndx++;
              if (ndx >= numChars) {
                  ndx = numChars - 1;
              }
          }
          else {
              //delay(10);     
              receivedChars[ndx] = '\0'; // terminate the string      // This function is now inside recieve character
              ndx = 0;                                                // There is no reason besides being easier to follow
              ledNumber = atoi(receivedChars);
              //Serial.println(ledarray_beg[ledNumber]);
              if (ledarray_beg[ledNumber] == 0){
                ledarray_beg[ledNumber] = 1;
               // Serial.println(ledarray_beg[ledNumber]); 
              }
              else{
                ledarray_beg[ledNumber] = 0;
               // Serial.println(ledarray_beg[ledNumber]);
                
              }
                        
          }    
      }
  }  

  void loop(){
    receiveValue();



    
    if(ledNumber != 0){
      //Serial.println(ledNumber);
      if(ledarray_beg[ledNumber] == 1){
        bool note_check = false; 
        for(i = 0;i<61;i++){
          if(ledNumber == keyboardSize[i]){
            note_check = true;
            //Serial.println("here");
                   
          }
         }

         if(note_check){
          leds[ledNumber] = CRGB::Red;
         }
         else{
          leds[ledNumber] = CRGB::Blue;
         }
      }
    else{
      leds[ledNumber] = CRGB::Black;
    }
    FastLED.show();   
    ledNumber = 0;
  }
 }

 // NOTES
// with only checking if LEDs on (1) or off (0) in array. System responds to any input with no error
// * with the exception of to many inputs in serial monitor. Seems at some point it just stops reading
// around 30 numbers (not including ',')
//^^ This is because the serial monitor can only hold 64 bytes, (64 characters)
// With checking all parameters, system still responds well. (current code)


